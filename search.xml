<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java的synchronized关键字]]></title>
    <url>%2F2018%2F12%2F29%2Fjava-synchronized%2F</url>
    <content type="text"><![CDATA[性质：可重入，不可中断两种用法：对象锁（方法锁，同步代码块锁），类锁（静态方法，class对象）多线程访问同步方法的7种情况加解锁原理（计数器加减），可重入原理，可见性原理（写回主内存再通信）书籍：Java并发编程实战 对象锁同步代码块123synchronized (this)&#123; n++;&#125; 1234567891011Object lock1 = new Object();Object lock2 = new Object();//两个lock锁定的不同代码块可以并行执行...synchronized (lock1)&#123; n++;&#125;synchronized (lock1)&#123; m++;&#125; 方法锁123public synchronized void addition()&#123; n++;&#125; 类锁静态方法123public synchronized static void addition()&#123; n++;&#125; class对象123synchronized (*.class)&#123; n++;&#125; 7种常见情况 两个线程同时访问一个对象的同步方法 – 串行 两个线程访问两个对象的同步方法 – 并行 两个线程访问synchronized得静态方法 – 串行 同时访问同步和非同步方法 – （一个线程访问同步方法，一个访问非同步，不影响）并行 访问同一个对象的不同的普通同步方法（非static方法） – （同一个实例默认使用this）串行 同时访问静态synchronized和非静态synchronized方法 – 并行 方法抛异常后会释放锁 – Lock类型的锁不会释放 性质可重入同一线程的外层函数获得锁之后，内层函数可直接再次获取该锁（同一把锁）内层函数可以是1.同一个方法2.不同方法3.不同类（子父类）好处：避免死锁，提升封装性粒度：线程而非调用（pthread的粒度是调用） 不可中断Lock接口123456Lock lock = new ReentrantLock();public void method()&#123; lock.lock(); n++; lock.unlock();&#125; 反编译12javac test.java //编译javap -verbose test.class //反编译查看字节码,-verbose把信息打印出来 缺陷 效率低：不可中断，不能设置超时，锁释放情况少 不够灵活：加锁释放时机单一，每个锁仅有单一条件（对比之下，读写锁更加灵活） 无法知道是否成功获取到锁 注意点锁对象不能为空作用域不宜过大避免死锁 Lock与synchronized尽量避免使用，可以使用java.util.concurrent包下的各种工具类synchronized代码更简洁同步访问的各种情况 锁的优化锁的升级降级，偏斜锁，轻量级锁，重量级锁]]></content>
      <categories>
        <category>计算机软件</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ehcache、memcache、redis比较]]></title>
    <url>%2F2018%2F12%2F28%2Fcaches-compare%2F</url>
    <content type="text"><![CDATA[EhcacheJava’s Most Widely-Used Cache文档较齐全，但是有点慢。 MemcacheMemcached works on most Linux and BSD like systems. There is no official support for windows builds.相关百科 Redis文档 引用链接ehcache、memcache、redis三大缓存比较Spring+EhCache缓存实例]]></content>
      <tags>
        <tag>java</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLSQL 基础]]></title>
    <url>%2F2018%2F12%2F28%2FPLSQL-basis%2F</url>
    <content type="text"><![CDATA[官方文档Database PL/SQL Language ReferencePL/SQL Packages and Types Reference 所有文档位置Oracle Database Documentation可选择对应版本的数据库并查看对应BookShelf 简介与HelloWorldProcedure Language/SQL是Oracle对SQL语言的过程化扩展，是面向过程的语言。不同数据库的SQL扩展：Oracle: PL/SQL;DB2: SQL/PL;SQL Server: Transac-SQL(T-SQL) 12345678910set serveroutput on-- 打开输出开关declare --说明部分begin -- 程序体 -- put_line里面的连接符是|| dbms_output.put_line('Hello World !');end;/ -- /只需要在SQL Plus中使用 Oracle默认事务级别是read Only所以需要在更改完成后commit;回滚使用rollback;可以在SQL Plus中使用命令desc 程序包名查看各个函数如: 123456789101112131415161718192021222324252627282930SQL&gt; desc dbms_outputPROCEDURE DISABLEPROCEDURE ENABLE参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- BUFFER_SIZE NUMBER(38) IN DEFAULTPROCEDURE GET_LINE参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- LINE VARCHAR2 OUT STATUS NUMBER(38) OUTPROCEDURE GET_LINES参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- LINES TABLE OF VARCHAR2(32767) OUT NUMLINES NUMBER(38) IN/OUTPROCEDURE GET_LINES参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- LINES DBMSOUTPUT_LINESARRAY OUT NUMLINES NUMBER(38) IN/OUTPROCEDURE NEW_LINEPROCEDURE PUT参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- A VARCHAR2 INPROCEDURE PUT_LINE参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- A VARCHAR2 IN 基础语法PL/SQL的程序结构 1234567declare--声明部分（变量，光标，例外）begin--语句序列（DML语句）exception--例外处理end; 定义基本变量类型：char,varchar2,date,number,boolean,long赋值运算:=和into（查询语句中使用）引用型变量var1 table.column%type记录型变量var2 table%rowtype，变量分量的引用var2.column if语句12345678910IF 条件 THEN 语句;语句; END IF;IF 条件 THEN 语句;语句;ELSE 语句;语句;END IF;IF 条件 THEN 语句;语句;ELSIF 条件 THEN 语句;ELSE 语句;语句;END IF; 12345678910set serveroutput onaccept num prompt'输入数字：'declarepn number(7,1) := &amp;num;beginif pn&lt;=0 then SYS.DBMS_OUTPUT.PUT_LINE('小于0');elsif pn=0 then SYS.DBMS_OUTPUT.PUT_LINE('等于0');else SYS.DBMS_OUTPUT.PUT_LINE('大于0');end if;end; 循环语句while循环while 条件 loop 循环体 end loop;loop循环loop EXIT when 条件1;[EXIT when 条件2;] 循环体 end loop;（常用，易于控制光标）for循环for I in m..n loop 循环体 end loop;如for p in 1..10 loop dbms_output.put_line(p) end loop; 光标Cursor相当于集合，因为Oracle没有数组集合语法CURSOR 光标名 [(参数名 数据类型[,参数名 数据类型]...)] IS SELECT 语句;打开光标open 光标名;取值fetch 光标名 into 变量名;关闭释放close 光标名;光标的属性：%found,%notfound,%isopen,%rowcount(影响的行数)光标数限制：默认一个会话300个show parameter cursor修改光标数alter system set open_cursors=400 scope=both(scope:both,memroy,spfile-数据库需重启) 带参数的光标：相当于高维数组的一维选择，定义和打开的时候带参数，定义带参数名，打开带具体参数。 例外Exception系统例外：no_data_found, too_many_rows, zero_divide, value_error, timeout_on_resource 123exception when no_data_found then 语句; when others then 语句; 自定义例外定义类型是exception的变量然后用raise抛出 Oracle的一些函数： NVL(expr1,expr2)如果expr1和expr2的数据类型一致，则：如果expr1为空(null),那么显示expr2，如果expr1的值不为空，则显示expr1。 NVL2(expr1,expr2, expr3)如果expr1不为NULL，返回expr2； expr1为NULL，返回expr3。expr2和expr3类型不同的话，expr3会转换为expr2的类型，转换不了，则报错。 NULLIF(expr1,expr2)如果expr1和expr2相等则返回空(NULL)，否则返回expr1。 coalesce(expr1, expr2, expr3,…,exprn)返回表达式中第一个非空表达式，如果都为空则返回空值。所有表达式必须是相同类型，或者可以隐式转换为相同的类型，否则报错。]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 基础操作]]></title>
    <url>%2F2018%2F12%2F28%2Foracle-basis%2F</url>
    <content type="text"><![CDATA[用户账号密码工具：SQL plussys,system,sysman:自己设定的密码scott:tiger错误警告密码7天后过期解决办法 12345678910111213141516SQL&gt;SELECT PROFILE FROM DBA_USERS WHERE USERNAME='SYS';PROFILE------------------------------DEFAULTSQL&gt;SQL&gt;SELECT RESOURCE_NAME,LIMIT FROM DBA_PROFILES WHERE PROFILE ='DEFAULT' AND RESOURCE_NAME='PASSWORD_LIFE_TIME';RESOURCE_NAME LIMIT------------------------------ ------------------------------PASSWORD_LIFE_TIME 180SQL&gt;alter profile &lt;profile_name&gt; limit password_life_time UNLIMITED; -- profile_name: DEFAULTSQL&gt;alter user `c##scott` identified by 123456; -- 如仍有警告则修改 用户登录：[username/password] [@server] [as sysdba|sysoper]如：system/root @orcl as sysdba登录之后切换换用户：[conn | connect] sys/root as sysdba查看当前用户：show user(非SQL语句可以不用分号结尾)用户信息可以使用sysdba身份查看dba_users字典启动和锁定用户账户:alter user username account lock/unlock; 表空间分类：永久表空间（存储表、视图等），临时表空间（数据库执行过程的临时空间），UNDO表空间（保存事务执行前的状态，可以进行回滚）dba_tablespaces,user_tablespaces数据字典 123456SQL&gt;select tablespace_name from dba_tablespaces/user_tablespaces;SYSTEM -- 系统表空间SYSAUX --Example辅助表空间UNDOTBS1 -- UNDO表空间TEMP --临时表空间USERS --用户表空间 dba_users,user_users数据字典oracle字符串使用单引号设置默认/临时表空间ALTER USER username DEFAULT|TEMPORARY TABLESPACE tablespace_name;创建表空间：CREATE [TEMPORARY] TABLESPACE tablespace_name TEMPFILE|DATAFILE &#39;test.dbf&#39; size 10m;其中test为文件名，10m为文件大小。文件名中可以设置文件路径否则在默认路径。查看数据文件位置： 123456789SQL&gt;select file_name from dba_data_files/dab_temp_files;FILE_NAME--------------------------------------------------------------------------------D:\APP\12148\VIRTUAL\ORADATA\ORCL\SYSTEM01.DBFD:\APP\12148\VIRTUAL\ORADATA\ORCL\SYSAUX01.DBFD:\APP\12148\VIRTUAL\ORADATA\ORCL\UNDOTBS01.DBFD:\APP\12148\VIRTUAL\ORADATA\ORCL\USERS01.DBFD:\APP\12148\VIRTUAL\ORADATA\ORCL\TEMP01.DBF 修改表空间状态ALTER TABLESPACE tablespace_name ONLINE|OFFLINE;查看状态select status from dba_tablespaces;表空间读写状态ALTER TABLESPACE tablespace_name READ ONLY | READ WRITE;（只读||可读写，都需要ONLINE状态下，ONLINE状态默认是READ WRITE，status的三种取值：OFFLINE、READ ONLY、ONLINE）增加数据文件ALTER TABLESPACE tablespace_name ADD DATAFILE &#39;xx.dbf&#39; SIZE xx;删除数据文件ALTER TABLESPACE tablespace_name DROP DATAFILE &#39;xx.dbf&#39;;（不能删除创建表空间时第一个数据文件）删除表空间DROP TABLESPACE tablespace_name [INCLUDING CONTENTS];（INCLUDING CONTENTS表示连同文件内容一起删除） 数据表数据类型：字符型，数值型，日期型，其他类型 字符型CHAR(n),NCHAR(n):NCHAR按照Unicode存储，汉字常使用此类型，charMaxn=2000,ncharMaxn=1000VARCHAR2(n),NVARCHAR2(n):不补充空格，不浪费空间，varcharMaxn=4000,nvarcharMaxn=2000 数值型NUMBER(p,s):p有效数字，s小数点后位数FLOAT(n):二进制 日期型DATE：范围-公元前4712年1月1日到公元9999年12月31日，精确到秒TIMESTAMP：精确到小数秒 其他类型(大对象)BLOB: 4GB,二进制CLOB: 4GB,字符串 创建表CREATE TABLE table_name(colum_name datatype,...);修改表： 添加字段ALTER TABLE table_name ADD column_name datatype; 修改字段数据类型ALTER TABLE table_name MODIFY column_name datatype; 删除字段ALTER TABLE table_name DROP COLUMN column_name; 修改字段名ALTER TABLE table_name RENAME COLUMN column_name TO new_name; 修改表名RENAME table_name TO new_name;截断表（清空数据）TRUNCATE TABLE table_name;删除表DROP TABLE table_name;添加数据INSERT INTO table_name(column1,column2,...) VALUES (value1,value2,...); 建表时复制CREATE TABLE table_new AS SELECT * FROM table_old;添加时复制INSERT INTO ... SELECT ... ;修改数据UPDATE table_name SET column1=&#39;...&#39;,column2=&#39;...&#39; [where conditions];删除数据DELETE FROM table_name [where conditions];(TRUNCATE速度更快) 约束查看约束信息user_constraints数据字典 非空约束NOT NULL非空约束没有名字使用MODIFYALTER TABLE table_name MODIFY column datatype NOT NULL; 主键约束PRIMARY KEY,表级约束CONSTRAINT constaint_name PRIMARY KEY(column_name1,...);修改表添加主键ALTER TABLE table_name ADD CONSTRAINT constaint_name PRIMARY KEY(column_name1,...);更改约束名称ALTER TABLE table_name CONSTRAINT old_name TO new_name;禁用/启用约束ALTER TABLE table_name DISABLE|ENABLE CONSTRAINT constaint_name;删除约束ALTER TABLE table_name DROP CONSTRAINT constaint_name;删除主键DROP PRIMARY KEY [CASCADE]; 外键约束FOREIGN KEY创建表时设置CREATE TABLE table1(column_name datatype REFERENCE table2(column_name),...);table2主表表级约束CONSTRAINT constaint_name FOREIGN KEY(column_name) REFERENCES table2(column_name) [ON DELETE CASCADE];主表删除，对应记录也被删除修改表时修改外键约束ALTER TABLE table_name ADD CONSTRAINT constaint_name FOREIGN KEY(column_name) REFERENCES table2(column_name) [ON DELETE CASCADE];禁用/启用约束，删除约束 唯一约束UNIQUE 检查约束CHECKCHECK(expressions)如salary number(10,0) check(salary &gt; 0) 查询语句SELECT [DISTINGCT] column_name,...|* FROM table_name [where conditions];SQL PLUS设置格式 别名COLUMN(COL) column_name HEADING new_name; a开头后面指定长度COL column_name FORMAT a10; 显示位数COL column_name FORMAT 999.9; 数字前面多个$符号COL column_name FORMAT $999.9; 清除格式COL column_name CLEAR;字段设置别名column_name [as] name; 逻辑运算符顺序 not &gt; and &gt; or比较运算符 &gt; 逻辑运算符模糊查询_%下划线代表任一字符，%代表任意多字符范围查询between ... and,in(...),not in()条件跳转case ... when ... then ... [else ...] end,case when ... then ... [else ...] enddecode函数decode(column_name,value1,result1,value2,result2,...,defaultValue)]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tushare数据平台]]></title>
    <url>%2F2018%2F12%2F27%2Ftushare-data%2F</url>
    <content type="text"><![CDATA[tushare PRO版本https://tushare.pro/register?reg=225995顺记一下比较好用的爬虫框架 tushare有专门的python库，最近的pro版新增了http接口。参数使用json模式(POSTMAN则选择BODY-raw-JSON)POST https://api.tushare.pro 123456&#123; "api_name":"stock_basic", "token":"you token", "params":&#123;"liststatus":"L"&#125;, "fields":""&#125;]]></content>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的资源网站]]></title>
    <url>%2F2018%2F12%2F25%2Fuseful-sources%2F</url>
    <content type="text"><![CDATA[Wallhaved壁纸网站Plxabay 免费的高清图片Gratisography免费高分辨率图片Splitshire 免费高清风景大图Unsplash 摄影师社区500px]]></content>
      <categories>
        <category>摄影图片</category>
      </categories>
      <tags>
        <tag>sourcesIndex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter入门]]></title>
    <url>%2F2018%2F12%2F25%2Fflutter-start%2F</url>
    <content type="text"><![CDATA[flutter中文网flutter官方网站github样例代码 Dart基础内置类型Number(num,int double),String,Boolean,Map,ListRunes, Symbols var, dynamic 数值操作~/ 取整除法字符串 * n: 复制n次插值表达式${expression}List的创建： 123var list = [1,2,3];var list = const [1,2,3]; // 常量Map类似var list = new List(); 复制运算符: ??= 如果变量为空则赋值 1234var a;a ??= 5;String b = "1";String c = a ?? b; 函数方法 构造函数继承类似C++冒号继承语法,key值是唯一确定元素。 switch里面的continue跳转到标签，类似goto 函数可选参数： 123456789//可选命名参数func(String name,&#123;int age, int gender&#125;)&#123; print("name=$name,age=$age,gender=$gender")&#125;//方括号调用的时候没有参数名称//可选位置参数func(String name,[int age, int gender])&#123; print("name=$name,age=$age,gender=$gender")&#125; 其他 123456789101112131415161718192021list.forEach(print) //方法对象()&#123; &#125; // 匿名方法// 闭包void main()&#123;var a = func();a(); //1a(); //2func()(); //1func()(); //1&#125;func()&#123;int _count = 0;return ()&#123; _count++; print(_count);&#125;;&#125; 异步支持Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。 async和await关键词支持了异步编程 Future.thenFuture.catchErrorFuture.delayedFuture.whenCompleteFuture.wait等待多个异步任务都执行结束后才进行下一步操作Async/await使用async/await消除callback hellasync用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。await 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。 1234567891011task() async &#123; try&#123; String id = await login("alice","******"); String userInfo = await getUserInfo(id); await saveUserInfo(userInfo); //执行接下来的操作 &#125; catch(e)&#123; //错误处理 print(e); &#125; &#125; 运行命令单个dart文件控制台输出dart lib/filename.dart（需配置dart环境变量使dart命令可以使用）flutter项目flutter run要关闭调试模式并使用发布模式，请使用flutter run --release运行您的应用程序。 这也关闭了Observatory调试器。一个中间模式可以关闭除Observatory之外所有调试辅助工具的，称为“profile mode”，用–profile替代–release即可。 国内镜像新增两个环境变量 12345PUB_HOSTED_URLhttps://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URLhttps://storage.flutter-io.cn 执行一下 flutter doctor命令下载在 package get 应该就没有问题了。 组件有状态组件StatelessWidget、无状态组件StatefulWidget TextWidget123456789textAlign:TextAlign.center,maxLines:1,overflow:TextOverflow.ellipsis,style:TextStyle( frontSize: 25.0, //浮点数 color: Color.fromARGB(255,255,255,255), //A:透明度 decoration: TextDecoration.underline, decorationStyle: TextDecorationStyle.solid) ContainerWidget12345678910111213alignment:Alignment.topLeft,padding:const EdgeInsets.fromLTRB(1,2,3,4), //设置左上右下四个方向的值//LinearGradient设置背景颜色渐变//BoxDecoration Widgetdecoration: new BoxDecoration( gradient: const LinearGradient( colors:[ Colors.lightBlue, Colors.greenAccent, Colors.purple ] )) ImageWidgetfit属性图片的混合模式repeat属性Image.asset: 加载资源图片，会被打包Image.network: 网络资源图片Image.file: 本地图片Image.memory: 加载到内存的图片 12345678910new Inmage.network( "url", scale:2.0,//图片缩放，值越大，图片越小 fit:BoxFit.fill, // fill拉伸图片布满容器, contain适应图片, cover布满容器自动裁剪 // fitWidth, fitHeight, scaleDown color:Colors.greenAccent, colorBlendMode: Blenmode.modulate, repeat:ImageRepeat.repeat) ListViewWidgetListTile 12345678910new ListView( children: &lt;Widget&gt;[ new ListTile( ), new ListTile( ), ]) 动态列表12345678new ListView.builder( itemCount: items.length, itemBuilder:(context,index)&#123; return new ListTile( title: new Text("$&#123;items[index]&#125;") ) &#125;) 横向列表Axis.horizontal/vertical GridView WidgetgridDelegate mainAxisSpacingcrossAxisSpacingcrossAxisCountchildAspectRatio: 0.8, 指的是width/height]]></content>
      <categories>
        <category>计算机软件</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>android</tag>
        <tag>dart</tag>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effective java]]></title>
    <url>%2F2018%2F12%2F24%2Feffective-java%2F</url>
    <content type="text"><![CDATA[第一章 开始effective java 主要涉及java.lang、java.util基本类库，某种程度上涉及java.util.concurrent和java.io共78条建议。 第二章 创建和销毁对象=========================== 1. 考虑使用静态方法工厂代替构造器2. 遇到多个构造器参数时考虑用构建器3. 用私有构造器或者枚举类型强化Singleton属性4. 通过私有构造器强化不可实例化的能力5. 避免创建不必要的对象6. 消除过期的对象引用7. 避免使用终结方法(finalizer)=========================== 第三章 所有对象通用方法=========================== 8. 覆盖equals时遵守通用约定9. 覆盖equals总是要覆盖hashCode10. 始终要覆盖toString11. 谨慎覆盖clone12. 考虑实现Comparable接口=========================== 第四章 类和接口=========================== 13. 使类和成员的可访问性最小化14. 在公有类中使用访问方法而不是公有域15. 使可变性最小化16. 复合优先于继承复合 17. 要么为继承而设计并提供文档说明，要么就禁止继承18. 接口优于抽象类接口 19. 接口只用于定义类型20. 类层次优于标签类类层次，标签类 21. 用函数对象表示策略22. 优先考虑静态成员类=========================== 第五章 泛型=========================== 23. 请不要再新代码中使用原生态类型原生态类型 24. 消除非受检警告有些警告比较难以消除，如果可以证明引起警告的代码是安全的，可以用@SuppressWarnings(“unchecked”) 25. 列表优于数组26. 优先考虑泛型27. 优先考虑泛型方法28. 利用有限的通配符来提升API的灵活性29. 优先考虑类型安全的异构容器调用方法时候不会混乱即类型安全，所有键值都是不同类型的即异构。 1234public class Favorites &#123; public &lt;T&gt; void putFavorites(Class&lt;T&gt; type, T instance); public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);&#125; =========================== 第六章 枚举和注解=========================== 30. 用Enum代替int常量31. 用实例域代替序数32. 用EnumSet代替位域33. 用EnumMap代替序数索引34. 用接口模拟可伸缩的枚举35. 注解优于命名模式36. 坚持使用Override注解37. 用标记接口定义类型=========================== 第七章 方法=========================== 38. 检查参数的有效性39. 必要时进行保护性拷贝40. 谨慎设计方法签名41. 慎用重载42. 慎用可变参数43. 返回零长度的数组或集合而不是null44. 为所有导出的API元素编写文档注释=========================== 第八章 通用程序设计=========================== 45. 将局部变量的作用域最小化46. for-each循环优于传统的for循环47. 了解和使用类库48. 如果需要精确的答案，请避免使用float和double49. 基本类型优于装箱基本类型50. 如果其他类型更合适，则尽量避免使用字符串51. 当心字符串连接的性能52. 通过接口引用对象53. 接口优于反射机制接口与反射机制 54. 谨慎地使用本地方法55. 谨慎地进行优化56. 遵守普遍接受的命名惯例=========================== 第九章 异常=========================== 57. 只针对异常情况才使用异常58. 对可恢复情况使用受检异常，对编程错误使用运行时异常受检异常 59. 避免不必要地使用受检的异常60. 优先使用标准的异常61. 抛出与抽象相对应的异常62. 每个方法抛出的异常都要有文档63. 在细节消息中包含能捕获失败的信息64. 努力使失败保持原子性65. 不要忽略异常=========================== 第十章 并发=========================== 66. 同步访问共享的可变数据67. 避免过度同步68. executor和task优先于线程69. 并发工具优先于wait和notify70. 线程安全性的文档化71. 慎用延迟初始化72. 不要依赖线程调度器73. 避免使用线程组=========================== 第十一章 序列化=========================== 74. 谨慎地实现Serializable接口75. 考虑使用自定义的序列化形式76. 保护性地编写readObject方法77. 对于实例控制，枚举类型优先于readResolve78. 考虑使用序列化代理代替序列化实例]]></content>
      <categories>
        <category>计算机软件</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记]]></title>
    <url>%2F2018%2F12%2F24%2Fdesign-model%2F</url>
    <content type="text"><![CDATA[概览根据模式的目的可分为：创建型，结构型和行为型 JavaScript设计模式相关书籍：《Learning JavaScript Design Patterns》 by Addy Osmani Java相关在线书籍和代码GitHub地址 面相对象设计原则1. 开闭原则一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 2. 里氏替换原则所有引用基类（父类）的地方必须能透明地使用其子类的对象。 3. 依赖转换原则抽象不应该依赖于细节，细节应当依赖于抽象。 4. 单一职责原则一个类只负责一个功能领域中的相应职责。 5. 合成复用原则尽量使用对象组合，而不是继承来达到复用的目的。 6. 迪米特法则一个软件实体应当尽可能少地与其他实体发生相互作用。 7. 接口隔离原则使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 使用频率高频率使用的模式: 工厂方法，抽象工厂，外观模式，迭代模式，观察者模式常用使用的模式：单例模式，适配器模式，代理模式，组合模式，策略模式，命令模式]]></content>
      <categories>
        <category>计算机软件</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令]]></title>
    <url>%2F2018%2F05%2F13%2Fmysql-frequently-used%2F</url>
    <content type="text"><![CDATA[新建数据库和归属用户在服务器上经常用mysql作不同用途，每个用途新建一个database和对应用户将访问权限分离开是良好的习惯。快速而方便地创建MySQL用户和数据库的语句： 1.创建数据库 1CREATE DATABASE databasename; 2.把数据库的所有权限归属到对应host下的用户并设置密码 12GRANT ALL PRIVILEGES ON databasename.* TO &quot;username&quot;@&quot;hostname&quot; IDENTIFIED BY &quot;password&quot;; 3.FLUSH清除或者重新加载内部缓存，使权限生效 1FLUSH PRIVILEGES;]]></content>
      <categories>
        <category>速查手册</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与NexT、markdown部分使用方法]]></title>
    <url>%2F2018%2F03%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo Quick Start 中文文档Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server -p 5000 More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment NexTfancybox是比较好的基于jQuery的图片预览插件 Markdown速记标题N个#号代表N级标题 字体加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… 分割线三个或者三个以上的 - 或者 * 都可以。 图片1![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;) 超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 列表无序列表用 - + * 任何一种都可以有序列表数字加点列表嵌套上一级和下一级之间缩进三个空格即可 第一章 第一节 第二节 第二章 表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 代码标签单行代码：代码之间分别用一个反引号`包起来代码块：代码之间分别用三个反引号12345678### 字体、字号、颜色```html&lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;微软雅黑&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 流程图需要插件支持，Hexo插件 hexo-filter-flowchart与代码块类似，语言写flow，内容按flow语法写就行 12345678910111213st=&gt;start: 开始e=&gt;end: 登录io1=&gt;inputoutput: 输入用户名密码sub1=&gt;subroutine: 数据库查询子类cond=&gt;condition: 是否有此用户cond2=&gt;condition: 密码是否正确op=&gt;operation: 读入用户信息st-&gt;io1-&gt;sub1-&gt;condcond(yes,right)-&gt;cond2cond(no)-&gt;io1(right)cond2(yes,right)-&gt;op-&gt;econd2(no)-&gt;io1 数学公式页面头部打开渲染开关mathjax: true行内$...$行间居中$$...$$ 上下标^ 表示上标，_ 表示下标。 12$a_&#123;1&#125;$,$x^&#123;2&#125;$,$e^&#123;-\alpha t&#125;$,$a^&#123;i&#125;_&#123;ij&#125;$$$\sideset&#123;^xy&#125;&#123;^xy&#125;\bigotimes$$ $a_{1}$,$x^{2}$,$e^{-\alpha t}$,$a^{i}_{ij}$$$\sideset{^xy}{^xy}\bigotimes$$ 平方根平方根输入命令为 \sqrt，n次方根命令为 \sqrt[n]$\sqrt{x}$ $\sqrt{x^2}+\sqrt{y}$ $\sqrt[3]{2}$ 1$\sqrt&#123;x&#125;$ $\sqrt&#123;x^2&#125;+\sqrt&#123;y&#125;$ $\sqrt[3]&#123;2&#125;$ 水平线使用 \overline 和 \underline 分别在表达式上下方画出水平线$\overline{m + n}$ $\underline{m + n}$ 1$\overline&#123;m + n&#125;$ $\underline&#123;m + n&#125;$ 水平大括号命令 \overbrace 和 \underrace，效果如下$\underbrace{a+b+\cdots+z}$$\overbrace{a+b+\cdots+z}$ 12$\underbrace&#123;a+b+\cdots+z&#125;$$\overbrace&#123;a+b+\cdots+z&#125;$ 矢量矢量的命令是 \vec，用于单个字母的向量表示。\overrightarrow 和\overleftarrow 分别表示向右和向左的向量箭头$\vec{a}$ $\overrightarrow{AB}$ $\overleftarrow{BA}$ 1$\vec&#123;a&#125;$ $\overrightarrow&#123;AB&#125;$ $\overleftarrow&#123;BA&#125;$ 分数分数使用 \frac{…}{…}$1\frac{1}{2}$ $\frac{x^2}{k+1}$ $x^{1/2}$ 1$1\frac&#123;1&#125;&#123;2&#125;$ $\frac&#123;x^2&#125;&#123;k+1&#125;$ $x^&#123;1/2&#125;$ 积分运算符积分运算符使用 \int 生成。求和运算符使用 \sum 生成。乘积运算符使用 \prod 生成。上下限使用^ 和_ 命令，类似 上下标$\sum_{i=1}^{n}$ $\int_{0}^{\frac{\pi}{2}}$ $\prod_\epsilon$ 1$\sum_&#123;i=1&#125;^&#123;n&#125;$ $\int_&#123;0&#125;^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125;$ $\prod_\epsilon$ 希腊字母$\alpha$ $\beta$ $\gamma$ $\delta$ $\epsilon$ 1$\alpha$ $\beta$ $\gamma$ $\delta$ $\epsilon$]]></content>
      <categories>
        <category>速查手册</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
